{
  "hash": "8390f7ba2b1e79b035301d39ca33c81c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Working with Stock Returns\naliases:\n  - ../introduction-to-tidy-finance.html\n  - ../r/introduction-to-tidy-finance.html\nmetadata:\n  pagetitle:  Working with Stock Returns in R\n  description-meta: Learn how to use the programming language R for downloading and analyzing stock market data.\n---\n\n\n\n\n::: callout-note\nYou are reading **Tidy Finance with R**. You can find the equivalent chapter for the sibling **Tidy Finance with Python** [here](../python/introduction-to-tidy-finance.qmd).\n:::\n\nThe main aim of this chapter is to familiarize yourself with the `tidyverse` for working with stock market data. We focus on downloading and visualizing stock data from Yahoo Finance.\n\nAt the start of each session, we load the required R packages. Throughout the entire book, we always use the `tidyverse` [@Wickham2019]. In this chapter, we also load the `tidyfinance` package to download stock price data. This package provides a convenient wrapper for various quantitative functions compatible with the `tidyverse` and our book.\\index{tidyverse} Finally, the package `scales` [@scales] provides useful scale functions for visualizations.\n\nYou typically have to install a package once before you can load it. In case you have not done this yet, call, for instance, `install.packages(\"tidyfinance\")`. \\index{tidyfinance}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidyfinance)\nlibrary(scales)\n```\n:::\n\n\n\n\nWe first download daily prices for one stock symbol, e.g., the Apple stock, *AAPL*, directly from the data provider Yahoo Finance. To download the data, you can use the function `download_data`. If you do not know how to use it, make sure you read the help file by calling `?download_data`. We especially recommend taking a look at the examples section of the documentation. We request daily data for a period of more than 20 years.\\index{Stock prices}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprices <- download_data(\n  type = \"stock_prices\",\n  symbols = \"AAPL\",\n  start_date = \"2000-01-01\",\n  end_date = \"2023-12-31\"\n)\nprices\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,037 × 8\n  symbol date          volume  open   low  high close adjusted_close\n  <chr>  <date>         <dbl> <dbl> <dbl> <dbl> <dbl>          <dbl>\n1 AAPL   2000-01-03 535796800 0.936 0.908 1.00  0.999          0.843\n2 AAPL   2000-01-04 512377600 0.967 0.903 0.988 0.915          0.772\n3 AAPL   2000-01-05 778321600 0.926 0.920 0.987 0.929          0.783\n4 AAPL   2000-01-06 767972800 0.948 0.848 0.955 0.848          0.716\n5 AAPL   2000-01-07 460734400 0.862 0.853 0.902 0.888          0.749\n# ℹ 6,032 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\\index{Data!Yahoo Finance} `download_data(type = \"stock_prices\")` downloads stock market data from Yahoo Finance. The function returns a tibble with eight quite self-explanatory columns: `symbol`, `date`, the daily `volume` (in the number of traded shares), the market prices at the `open`, `high`, `low`, `close`, and the `adjusted` price in USD. The adjusted prices are corrected for anything that might affect the stock price after the market closes, e.g., stock splits and dividends. These actions affect the quoted prices, but they have no direct impact on the investors who hold the stock. Therefore, we often rely on adjusted prices when it comes to analyzing the returns an investor would have earned by holding the stock continuously.\\index{Stock price adjustments}\n\nNext, we use the `ggplot2` package [@ggplot2] to visualize the time series of adjusted prices in @fig-100 . This package takes care of visualization tasks based on the principles of the grammar of graphics [@Wilkinson2012].\\index{Graph!Time series}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprices |>\n  ggplot(aes(x = date, y = adjusted_close)) +\n  geom_line() +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Apple stock prices between beginning of 2000 and end of 2023\"\n  )\n```\n\n::: {.cell-output-display}\n![Prices are in USD, adjusted for dividend payments and stock splits.](working-with-stock-returns_files/figure-html/fig-100-1.png){#fig-100 fig-alt='Title: Apple stock prices between the beginning of 2000 and the end of 2023. The figure shows that the stock price of Apple increased dramatically from about 1 USD to around 125 USD.' width=2100}\n:::\n:::\n\n\n\n\n\\index{Returns} Instead of analyzing prices, we compute daily net returns defined as $r_t = p_t / p_{t-1} - 1$, where $p_t$ is the adjusted day $t$ price. In that context, the function `lag()` is helpful, which returns the previous value in a vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns <- prices |>\n  arrange(date) |>\n  mutate(ret = adjusted_close / lag(adjusted_close) - 1) |>\n  select(symbol, date, ret)\nreturns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,037 × 3\n  symbol date           ret\n  <chr>  <date>       <dbl>\n1 AAPL   2000-01-03 NA     \n2 AAPL   2000-01-04 -0.0843\n3 AAPL   2000-01-05  0.0146\n4 AAPL   2000-01-06 -0.0865\n5 AAPL   2000-01-07  0.0474\n# ℹ 6,032 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThe resulting tibble contains three columns, where the last contains the daily returns (`ret`). Note that the first entry naturally contains a missing value (`NA`) because there is no previous price.\\index{Missing value} Obviously, the use of `lag()` would be meaningless if the time series is not ordered by ascending dates.\\index{Lag observations} The command `arrange()` provides a convenient way to order observations in the correct way for our application. In case you want to order observations by descending dates, you can use `arrange(desc(date))`.\n\nFor the upcoming examples, we remove missing values as these would require separate treatment when computing, e.g., sample averages. In general, however, make sure you understand why `NA` values occur and carefully examine if you can simply get rid of these observations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns <- returns |>\n  drop_na(ret)\n```\n:::\n\n\n\n\nNext, we visualize the distribution of daily returns in a histogram in @fig-101. \\index{Graph!Histogram} Additionally, we add a dashed line that indicates the 5 percent quantile of the daily returns to the histogram, which is a (crude) proxy for the worst return of the stock with a probability of at most 5 percent. The 5 percent quantile is closely connected to the (historical) value-at-risk, a risk measure commonly monitored by regulators. \\index{Value-at-risk} We refer to @Tsay2010 for a more thorough introduction to stylized facts of returns.\\index{Returns}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile_05 <- quantile(returns |> pull(ret), probs = 0.05)\nreturns |>\n  ggplot(aes(x = ret)) +\n  geom_histogram(bins = 100) +\n  geom_vline(aes(xintercept = quantile_05),\n    linetype = \"dashed\"\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Distribution of daily Apple stock returns\"\n  ) +\n  scale_x_continuous(labels = percent)\n```\n\n::: {.cell-output-display}\n![The dotted vertical line indicates the historical 5 percent quantile.](working-with-stock-returns_files/figure-html/fig-101-1.png){#fig-101 fig-alt='Title: Distribution of daily Apple stock returns in percent. The figure shows a histogram of daily returns. The range indicates a few large negative values, while the remaining returns are distributed around 0. The vertical line indicates that the historical 5 percent quantile of daily returns was around negative 3 percent.' width=2100}\n:::\n:::\n\n\n\n\nHere, `bins = 100` determines the number of bins used in the illustration and hence implicitly the width of the bins. Before proceeding, make sure you understand how to use the geom `geom_vline()` to add a dashed line that indicates the 5 percent quantile of the daily returns. A typical task before proceeding with *any* data is to compute summary statistics for the main variables of interest.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns |>\n  summarize(across(\n    ret,\n    list(\n      daily_mean = mean,\n      daily_sd = sd,\n      daily_min = min,\n      daily_max = max\n    )\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  ret_daily_mean ret_daily_sd ret_daily_min ret_daily_max\n           <dbl>        <dbl>         <dbl>         <dbl>\n1        0.00122       0.0247        -0.519         0.139\n```\n\n\n:::\n:::\n\n\n\n\nWe see that the maximum *daily* return was 13.905 percent. Perhaps not surprisingly, the average daily return is close to but slightly above 0. In line with the illustration above, the large losses on the day with the minimum returns indicate a strong asymmetry in the distribution of returns.\\\nYou can also compute these summary statistics for each year individually by imposing `group_by(year = year(date))`, where the call `year(date)` returns the year. More specifically, the few lines of code below compute the summary statistics from above for individual groups of data defined by year. The summary statistics, therefore, allow an eyeball analysis of the time-series dynamics of the return distribution.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns |>\n  group_by(year = year(date)) |>\n  summarize(across(\n    ret,\n    list(\n      daily_mean = mean,\n      daily_sd = sd,\n      daily_min = min,\n      daily_max = max\n    ),\n    .names = \"{.fn}\"\n  )) |>\n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 5\n    year daily_mean daily_sd daily_min daily_max\n   <dbl>      <dbl>    <dbl>     <dbl>     <dbl>\n 1  2000 -0.00346     0.0549   -0.519     0.137 \n 2  2001  0.00233     0.0393   -0.172     0.129 \n 3  2002 -0.00121     0.0305   -0.150     0.0846\n 4  2003  0.00186     0.0234   -0.0814    0.113 \n 5  2004  0.00470     0.0255   -0.0558    0.132 \n 6  2005  0.00349     0.0245   -0.0921    0.0912\n 7  2006  0.000950    0.0243   -0.0633    0.118 \n 8  2007  0.00366     0.0238   -0.0702    0.105 \n 9  2008 -0.00265     0.0367   -0.179     0.139 \n10  2009  0.00382     0.0214   -0.0502    0.0676\n11  2010  0.00183     0.0169   -0.0496    0.0769\n12  2011  0.00104     0.0165   -0.0559    0.0589\n13  2012  0.00130     0.0186   -0.0644    0.0887\n14  2013  0.000472    0.0180   -0.124     0.0514\n15  2014  0.00145     0.0136   -0.0799    0.0820\n16  2015  0.0000199   0.0168   -0.0612    0.0574\n17  2016  0.000575    0.0147   -0.0657    0.0650\n18  2017  0.00164     0.0111   -0.0388    0.0610\n19  2018 -0.0000573   0.0181   -0.0663    0.0704\n20  2019  0.00266     0.0165   -0.0996    0.0683\n21  2020  0.00281     0.0294   -0.129     0.120 \n22  2021  0.00131     0.0158   -0.0417    0.0539\n23  2022 -0.000970    0.0225   -0.0587    0.0890\n24  2023  0.00168     0.0128   -0.0480    0.0469\n```\n\n\n:::\n:::\n\n\n\n\n\\index{Summary statistics}\n\nIn case you wonder: the additional argument `.names = \"{.fn}\"` in `across()` determines how to name the output columns. The specification is rather flexible and allows almost arbitrary column names, which can be useful for reporting. The `print()` function simply controls the output options for the R console.\n\n## Scaling Up the Analysis\n\nAs a next step, we generalize the code from before such that all the computations can handle an arbitrary vector of symbols (e.g., all constituents of an index). Following tidy principles, it is quite easy to download the data, plot the price time series, and tabulate the summary statistics for an arbitrary number of assets.\n\nThis is where the `tidyverse` magic starts: tidy data makes it extremely easy to generalize the computations from before to as many assets as you like. The following code takes any vector of symbols, e.g., `symbol <- c(\"AAPL\", \"MMM\", \"BA\")`, and automates the download as well as the plot of the price time series. In the end, we create the table of summary statistics for an arbitrary number of assets. We perform the analysis with data from all current constituents of the [Dow Jones Industrial Average index.](https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average) \\index{Data!Dow Jones Index}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymbols <- download_data(type = \"constituents\", index = \"Dow Jones Industrial Average\") \nsymbols\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 30 × 5\n  symbol name                    location           exchange currency\n  <chr>  <chr>                   <chr>              <chr>    <chr>   \n1 GS     GOLDMAN SACHS GROUP INC Vereinigte Staaten New Yor… USD     \n2 UNH    UNITEDHEALTH GROUP INC  Vereinigte Staaten New Yor… USD     \n3 MSFT   MICROSOFT CORP          Vereinigte Staaten NASDAQ   USD     \n4 HD     HOME DEPOT INC          Vereinigte Staaten New Yor… USD     \n5 CAT    CATERPILLAR INC         Vereinigte Staaten New Yor… USD     \n# ℹ 25 more rows\n```\n\n\n:::\n:::\n\n\n\n\nConveniently, `tidyfinance` provides the functionality to get all stock prices from an index with a single call. \\index{Exchange!NASDAQ}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprices_daily <- download_data(\n  type = \"stock_prices\",\n  symbols = symbols$symbol,\n  start_date = \"2000-01-01\",\n  end_date = \"2023-12-31\"\n)\n```\n:::\n\n\n\n\nThe resulting tibble contains 177925 daily observations for GS, UNH, MSFT, HD, CAT, SHW, CRM, V, AXP, MCD, AMGN, AAPL, TRV, JPM, HON, AMZN, IBM, BA, PG, CVX, JNJ, NVDA, MMM, DIS, MRK, WMT, NKE, KO, CSCO, VZ different stocks. @fig-103 illustrates the time series of downloaded *adjusted* prices for each of the constituents of the Dow index. Make sure you understand every single line of code! What are the arguments of `aes()`? Which alternative `geoms` could you use to visualize the time series? Hint: if you do not know the answers try to change the code to see what difference your intervention causes.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_prices <- prices_daily |>\n  ggplot(aes(\n    x = date,\n    y = adjusted_close,\n    color = symbol\n  )) +\n  geom_line() +\n  labs(\n    x = NULL,\n    y = NULL,\n    color = NULL,\n    title = \"Stock prices of Dow index constituents\"\n  ) +\n  theme(legend.position = \"none\")\nfig_prices\n```\n\n::: {.cell-output-display}\n![Prices in USD, adjusted for dividend payments and stock splits.](working-with-stock-returns_files/figure-html/fig-103-1.png){#fig-103 fig-alt='Title: Stock prices of Dow index constituents. The figure shows many time series with daily prices. The general trend seems positive for most stocks in the Dow index.' width=2100}\n:::\n:::\n\n\n\n\nDo you notice the small differences relative to the code we used before? All we need to do to illustrate all stock symbols simultaneously is to include `color = symbol` in the `ggplot` aesthetics. In this way, we generate a separate line for each symbol. Of course, there are simply too many lines on this graph to identify the individual stocks properly, but it illustrates the point well.\n\nThe same holds for stock returns. Before computing the returns, we use `group_by(symbol)` such that the `mutate()` command is performed for each symbol individually. The same logic also applies to the computation of summary statistics: `group_by(symbol)` is the key to aggregating the time series into symbol-specific variables of interest.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns_daily <- prices_daily |>\n  group_by(symbol) |>\n  mutate(ret = adjusted_close / lag(adjusted_close) - 1) |>\n  select(symbol, date, ret) |>\n  drop_na(ret)\n\nreturns_daily |>\n  group_by(symbol) |>\n  summarize(across(\n    ret,\n    list(\n      daily_mean = mean,\n      daily_sd = sd,\n      daily_min = min,\n      daily_max = max\n    ),\n    .names = \"{.fn}\"\n  )) |>\n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 30 × 5\n   symbol daily_mean daily_sd daily_min daily_max\n   <chr>       <dbl>    <dbl>     <dbl>     <dbl>\n 1 AAPL     0.00122    0.0247    -0.519     0.139\n 2 AMGN     0.000493   0.0194    -0.134     0.151\n 3 AMZN     0.00107    0.0315    -0.248     0.345\n 4 AXP      0.000544   0.0227    -0.176     0.219\n 5 BA       0.000628   0.0222    -0.238     0.243\n 6 CAT      0.000724   0.0203    -0.145     0.147\n 7 CRM      0.00119    0.0266    -0.271     0.260\n 8 CSCO     0.000322   0.0234    -0.162     0.244\n 9 CVX      0.000511   0.0175    -0.221     0.227\n10 DIS      0.000414   0.0194    -0.184     0.160\n11 GS       0.000557   0.0229    -0.190     0.265\n12 HD       0.000544   0.0192    -0.287     0.141\n13 HON      0.000497   0.0191    -0.174     0.282\n14 IBM      0.000297   0.0163    -0.155     0.120\n15 JNJ      0.000379   0.0121    -0.158     0.122\n16 JPM      0.000606   0.0238    -0.207     0.251\n17 KO       0.000318   0.0131    -0.101     0.139\n18 MCD      0.000536   0.0145    -0.159     0.181\n19 MMM      0.000363   0.0151    -0.129     0.126\n20 MRK      0.000371   0.0166    -0.268     0.130\n21 MSFT     0.000573   0.0193    -0.156     0.196\n22 NKE      0.000708   0.0193    -0.198     0.155\n23 NVDA     0.00175    0.0376    -0.352     0.424\n24 PG       0.000362   0.0133    -0.302     0.120\n25 SHW      0.000860   0.0180    -0.208     0.153\n26 TRV      0.000555   0.0181    -0.208     0.256\n27 UNH      0.000948   0.0196    -0.186     0.348\n28 V        0.000933   0.0185    -0.136     0.150\n29 VZ       0.000238   0.0151    -0.118     0.146\n30 WMT      0.000323   0.0148    -0.114     0.117\n```\n\n\n:::\n:::\n\n\n\n\n\\index{Summary statistics}\n\nNote that you are now also equipped with all tools to download price data for *each* symbol listed in the S&P 500 index with the same number of lines of code. Just use `symbol <- download_data(type = \"constituents\", index = \"S&P 500\")`, which provides you with a tibble that contains each symbol that is (currently) part of the S&P 500.\\index{Data!SP 500} However, don't try this if you are not prepared to wait for a couple of minutes because this is quite some data to download!\n\n## Other Forms of Data Aggregation\n\nOf course, aggregation across variables other than `symbol` can also make sense. For instance, suppose you are interested in answering the question: Are days with high aggregate trading volume likely followed by days with high aggregate trading volume? To provide some initial analysis on this question, we take the downloaded data and compute aggregate daily trading volume for all Dow index constituents in USD. Recall that the column `volume` is denoted in the number of traded shares.\\index{Trading volume} Thus, we multiply the trading volume with the daily closing price to get a proxy for the aggregate trading volume in USD. Scaling by `1e9` (R can handle scientific notation) denotes daily trading volume in billion USD.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrading_volume <- prices_daily |>\n  group_by(date) |>\n  summarize(trading_volume = sum(volume * adjusted_close))\n\nfig_trading_volume <- trading_volume |>\n  ggplot(aes(x = date, y = trading_volume)) +\n  geom_line() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Aggregate daily trading volume of Dow index constitutens\"\n  ) +\n    scale_y_continuous(labels = unit_format(unit = \"B\", scale = 1e-9))\nfig_trading_volume\n```\n\n::: {.cell-output-display}\n![Total daily trading volume in billion USD.](working-with-stock-returns_files/figure-html/fig-104-1.png){#fig-104 fig-alt='Title: Aggregate daily trading volume. The figure shows a volatile time series of daily trading volume, ranging from 15 in 2000 to 20.5 in 2023, with a maximum of more than 100.' width=2100}\n:::\n:::\n\n\n\n\n@fig-104 indicates a clear upward trend in aggregated daily trading volume. In particular, since the outbreak of the COVID-19 pandemic, markets have processed substantial trading volumes, as analyzed, for instance, by @Goldstein2021.\\index{Covid 19} One way to illustrate the persistence of trading volume would be to plot volume on day $t$ against volume on day $t-1$ as in the example below. In @fig-105, we add a dotted 45°-line to indicate a hypothetical one-to-one relation by `geom_abline()`, addressing potential differences in the axes' scales.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_persistence <- trading_volume |>\n  ggplot(aes(x = lag(trading_volume), y = trading_volume)) +\n  geom_point() +\n  geom_abline(aes(intercept = 0, slope = 1),\n    linetype = \"dashed\"\n  ) +\n  labs(\n    x = \"Previous day aggregate trading volume\",\n    y = \"Aggregate trading volume\",\n    title = \"Persistence in daily trading volume of Dow index constituents\"\n  ) + \n  scale_x_continuous(labels = unit_format(unit = \"B\", scale = 1e-9)) +\n  scale_y_continuous(labels = unit_format(unit = \"B\", scale = 1e-9))\nfig_persistence\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Total daily trading volume in billion USD.](working-with-stock-returns_files/figure-html/fig-105-1.png){#fig-105 fig-alt='Title: Persistence in daily trading volume of Dow index constituents. The figure shows a scatterplot where aggregate trading volume and previous-day aggregate trading volume neatly line up along a 45-degree line.' width=2100}\n:::\n:::\n\n\n\n\nDo you understand where the warning `## Warning: Removed 1 rows containing missing values (geom_point).` comes from and what it means? Purely eye-balling reveals that days with high trading volume are often followed by similarly high trading volume days.\\index{Error message}\n\n## Key Takeaways\n\nIn this chapter, you learned how to effectively use R to download, analyze, and visualize stock market data using tidy principles. From downloading adjusted stock prices to computing returns, summarizing statistics, and visualizing trends, we have laid a solid foundation for working with financial data. Key takeaways include the importance of using adjusted prices for return calculations, leveraging `tidyverse`-tools for efficient data manipulation, and employing visualizations like histograms and line charts to uncover insights. Scaling up analyses to handle multiple stocks or broader indices demonstrates the flexibility of tidy data workflows. Equipped with these foundational techniques, you are now ready to apply them to different contexts in financial economics coming in subsequent chapters.\n\n## Exercises\n\n1. Download daily prices for another stock market symbol of your choice from Yahoo Finance with `download_data()` from the `tidyfinance` package. Plot two time series of the symbol’s un-adjusted and adjusted closing prices. Explain the differences.\n1. Compute daily net returns for an asset of your choice and visualize the distribution of daily returns in a histogram using 100 bins. Also, use `geom_vline()` to add a dashed red vertical line that indicates the 5 percent quantile of the daily returns. Compute summary statistics (mean, standard deviation, minimum and maximum) for the daily returns.\n1. Take your code from before and generalize it such that you can perform all the computations for an arbitrary vector of symbols (e.g., `symbol <- c(\"AAPL\", \"MMM\", \"BA\")`). Automate the download, the plot of the price time series, and create a table of return summary statistics for this arbitrary number of assets.\n1. Are days with high aggregate trading volume often also days with large absolute returns? Find an appropriate visualization to analyze the question using the symbol `AAPL`.\n1.Compute monthly returns from the downloaded stock market prices. Compute the vector of historical average returns and the sample variance-covariance matrix. Compute the minimum variance portfolio weights and the portfolio volatility and average returns. Visualize the mean-variance efficient frontier. Choose one of your assets and identify the portfolio which yields the same historical volatility but achieves the highest possible average return.\n",
    "supporting": [
      "working-with-stock-returns_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}